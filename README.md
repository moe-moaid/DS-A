# ðŸ”¹ Data Structures Cheat Sheet
| DS                           | Main Operations                              | Time Complexity                              | Space           | Use Cases                                    | Pros                                   | Cons                                           |
| ---------------------------- | -------------------------------------------- | -------------------------------------------- | --------------- | -------------------------------------------- | -------------------------------------- | ---------------------------------------------- |
| **Array**                    | Access: O(1), Insert/Delete: O(n)            | O(1) access, O(n) insert/delete              | O(n)            | Lookup by index, small static datasets       | Fast random access, memory locality    | Costly insert/delete, fixed size in some langs |
| **Linked List**              | Insert/Delete: O(1), Access: O(n)            | O(n) access, O(1) insert/delete (given node) | O(n) + pointers | Dynamic memory, frequent inserts/deletes     | Flexible size, efficient insert/delete | Slow access, extra memory for pointers         |
| **Stack**                    | Push/Pop: O(1)                               | O(1)                                         | O(n)            | Undo/Redo, expression parsing, DFS           | Simple, fast ops                       | Only top element accessible                    |
| **Queue**                    | Enqueue/Dequeue: O(1)                        | O(1)                                         | O(n)            | Scheduling, BFS, producer-consumer           | Simple FIFO order                      | Only front/back accessible                     |
| **HashMap / HashSet**        | Insert/Lookup/Delete: O(1) avg               | O(1) avg, O(n) worst                         | O(n)            | Caching, frequency count, fast lookup        | Very fast, flexible keys               | No guaranteed order, collisions possible       |
| **Binary Search Tree (BST)** | Insert/Search/Delete: O(log n) (if balanced) | O(log n) balanced, O(n) skewed               | O(n)            | Sorted data, range queries, order statistics | Maintains sorted order, log n ops      | Can degrade to O(n) if unbalanced              |
| **Heap (Priority Queue)**    | Insert: O(log n), Extract-min/max: O(log n)  | O(log n)                                     | O(n)            | Scheduling, shortest path (Dijkstra)         | Good for min/max ops                   | No fast lookup (search O(n))                   |
| **Graph**                    | Add edge: O(1), Traverse: O(V+E)             | BFS/DFS: O(V+E)                              | O(V+E)          | Social networks, pathfinding                 | Models complex relations               | Can be large, costly traversal                 |
